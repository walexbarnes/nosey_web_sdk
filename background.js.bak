// Background script for Adobe Web SDK Inspector

// Global variable to track whether the extension is listening
let isListening = false;
let targetPaths = [];
let requestCache = new Map(); // Cache to store request data temporarily
let debugMode = true; // Enable extra debugging info
let requestCounter = 0; // Counter to track requests
let devToolsConnections = new Set(); // Track active DevTools connections

// Function to sanitize target paths - remove unwanted intel/experience paths
function sanitizeTargetPaths(paths) {
  if (!Array.isArray(paths)) {
    console.error('[DEBUG] Paths is not an array:', paths);
    return getDefaultPaths();
  }

  // List of bad path prefixes to filter out
  const badPrefixes = [
    '_experience.analytics',
    '_intelcorp',
    'meta.state',
    'timestamp'
  ];
  
  // Default good paths we always want
  const defaultPaths = getDefaultPaths();
  
  // Filter out bad paths
  const cleanPaths = paths.filter(path => 
    !badPrefixes.some(prefix => path.includes(prefix))
  );
  
  // Combine with defaults and deduplicate
  const result = [...new Set([...defaultPaths, ...cleanPaths])];
  
  console.log('[DEBUG] Sanitized paths. Original:', paths.length, 'Final:', result.length);
  return result;
}

// Get the default target paths
function getDefaultPaths() {
  return [
    'eventType',
    'web.webPageDetails.URL',
    'web.webInteraction.name',
    'web.webInteraction.region'
  ];
}

// On install or update, ensure the extension has the correct permissions
chrome.runtime.onInstalled.addListener(() => {
  console.log('[DEBUG] Adobe Web SDK Inspector extension installed/updated');
  
  // Reset paths to defaults on install/update
  chrome.storage.local.set({ 
    targetPaths: getDefaultPaths(),
    extensionVersion: '1.0.4'  // Increment version number
  });
});

// Initialize state from storage
chrome.storage.local.get(['isListening', 'targetPaths', 'debugMode'], (result) => {
  if (result.isListening !== undefined) {
    isListening = result.isListening;
  }
  
  if (result.debugMode !== undefined) {
    debugMode = result.debugMode;
  }
  
  // Always sanitize the paths when loading from storage
  if (result.targetPaths && Array.isArray(result.targetPaths)) {
    targetPaths = sanitizeTargetPaths(result.targetPaths);
    // Save the sanitized paths back to storage
    chrome.storage.local.set({ targetPaths });
  } else {
    // Use defaults if no paths in storage
    targetPaths = getDefaultPaths();
    chrome.storage.local.set({ targetPaths });
  }
  
  console.log('[DEBUG] Initialized state:', { isListening, targetPaths, debugMode });
});

// Output initialization message
console.log('[DEBUG] Adobe Web SDK Inspector background script activated');

// Track connections from DevTools panels
chrome.runtime.onConnect.addListener((port) => {
  console.log(`[DEBUG] New connection from: ${port.name}`);
  
  if (port.name === 'devtools-panel') {
    devToolsConnections.add(port);
    console.log(`[DEBUG] DevTools panel connected. Active connections: ${devToolsConnections.size}`);
    
    // Clean up when DevTools disconnects
    port.onDisconnect.addListener(() => {
      devToolsConnections.delete(port);
      console.log(`[DEBUG] DevTools panel disconnected. Remaining connections: ${devToolsConnections.size}`);
    });
    
    // Listen for messages from this DevTools panel
    port.onMessage.addListener((message) => {
      console.log(`[DEBUG] Message from DevTools panel:`, message);
      // Handle messages as needed
    });
  }
});

// Helper function to send messages to all connected DevTools panels
function sendToDevTools(message) {
  console.log(`[DEBUG] Attempting to send to ${devToolsConnections.size} DevTools connections`);
  
  if (devToolsConnections.size === 0) {
    console.log(`[DEBUG] No active DevTools connections, using runtime.sendMessage fallback`);
    try {
      chrome.runtime.sendMessage(message).catch((err) => {
        console.log(`[DEBUG] Expected error from runtime.sendMessage: ${err.message}`);
      });
    } catch (e) {
      console.log(`[DEBUG] Error in runtime.sendMessage fallback: ${e.message}`);
    }
    return;
  }
  
  // Send to all connected DevTools panels
  for (const port of devToolsConnections) {
    try {
      port.postMessage(message);
      console.log(`[DEBUG] Successfully sent message to DevTools panel`);
    } catch (e) {
      console.error(`[DEBUG] Error sending to DevTools port: ${e.message}`);
      // Remove bad connection
      devToolsConnections.delete(port);
    }
  }
}

// Listen for messages from other extension components
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  try {
    console.log(`[DEBUG] Message received:`, message, `from:`, sender.id || 'unknown');
    
    if (message.action === 'toggleListening') {
      isListening = message.value;
      console.log('[DEBUG] Listening status changed to:', isListening);
      chrome.storage.local.set({ isListening });
      sendResponse({ status: 'success' });
    } else if (message.action === 'updatePaths') {
      // Sanitize paths before saving them
      targetPaths = sanitizeTargetPaths(message.paths);
      console.log('[DEBUG] Target paths updated and sanitized:', targetPaths);
      chrome.storage.local.set({ targetPaths });
      sendResponse({ status: 'success', sanitizedPaths: targetPaths });
    } else if (message.action === 'getStatus') {
      // Always sanitize paths before sending them
      targetPaths = sanitizeTargetPaths(targetPaths);
      chrome.storage.local.set({ targetPaths }); // Save sanitized paths
      
      sendResponse({
        isListening,
        targetPaths,
        debugMode
      });
    } else if (message.action === 'toggleDebug') {
      debugMode = message.value;
      console.log('[DEBUG] Debug mode changed to:', debugMode);
      chrome.storage.local.set({ debugMode });
      sendResponse({ status: 'success' });
    } else if (message.action === 'devtools-init') {
      console.log('[DEBUG] DevTools panel initialization message received');
      sendResponse({ status: 'success' });
    }
  } catch (error) {
    console.error('[DEBUG] Error handling message:', error);
    sendResponse({ status: 'error', message: error.message });
  }
  
  return true; // Indicate async response
});

// Function to get a deeply nested property using a path string
const getNestedProperty = (obj, path) => {
  const keys = path.split('.');
  return keys.reduce((acc, key) => (acc && acc[key] !== undefined) ? acc[key] : undefined, obj);
};

// Function to check if a URL is an Adobe Web SDK URL
function isAdobeWebSdkUrl(url) {
  // ONLY process a request if it has BOTH configId AND requestId in query parameters
  // AND has /ee/ in the request path
  return url.includes('/ee/') && 
         url.includes('configId=') && 
         url.includes('requestId=');
}

// Function to determine request type (ping, fetch, etc.)
function getRequestType(url, reqType, headers) {
  // Check if it's a fetch request
  if (reqType === 'fetch' || url.includes('fetch')) {
    return 'fetch';
  }
  
  // Default to the Chrome request type
  return reqType;
}

// Helper function to safely parse JSON with fallback
function safeParseJson(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    console.error('Error parsing JSON:', e);
    return null;
  }
}

// Process the request data and send results
function processRequestData(requestData, url, requestInfo = {}) {
  try {
    requestCounter++;
    console.log(`[DEBUG] Processing request #${requestCounter}: ${url}`);
    console.log(`[DEBUG] Request info:`, JSON.stringify(requestInfo));
    
    // ECID DEBUG: Log the full request info to help troubleshoot
    console.log(`[ECID DEBUG] Full requestInfo object:`, requestInfo);
    
    const jsonData = safeParseJson(requestData);
    if (!jsonData) {
      if (debugMode) {
        console.error('[DEBUG] Failed to parse JSON data for URL:', url);
      }
      return;
    }
    
    console.log(`[DEBUG] Parsed JSON data structure:`, Object.keys(jsonData));
    
    // Standard processing for requests
    if (jsonData.events) {
      console.log(`[DEBUG] Events array length:`, jsonData.events.length);
    }
    
    // Process each event in the payload
    if (jsonData.events && Array.isArray(jsonData.events)) {
      console.log(`[DEBUG] Processing events array with ${jsonData.events.length} events`);
      const results = {};
      let hasMatches = false;
      
      // Get the first event's XDM data
      const event = jsonData.events[0];
      console.log(`[DEBUG] Event structure:`, Object.keys(event));
      const targetObject = event.xdm || event;
      console.log(`[DEBUG] Target object structure:`, Object.keys(targetObject));
      
      // Add eventType as a standard field if not already specified in targetPaths
      if (!targetPaths.includes('eventType') && targetObject.eventType) {
        console.log(`[DEBUG] Adding eventType to results: ${targetObject.eventType}`);
        results['eventType'] = targetObject.eventType;
        hasMatches = true;
      }
      
      // Extract the specified target paths from the XDM
      console.log(`[DEBUG] Searching for ${targetPaths.length} target paths in data`);
      targetPaths.forEach(path => {
        const value = getNestedProperty(targetObject, path);
        if (value !== undefined) {
          console.log(`[DEBUG] Found match for path ${path}:`, value);
          results[path] = value;
          hasMatches = true;
        } else {
          console.log(`[DEBUG] No match found for path ${path}`);
        }
      });
      
      // If we found any matches, log them
      if (hasMatches) {
        console.log(`[DEBUG] Has matches: ${hasMatches}. Results:`, results);
        // Send to content script to display
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
          if (tabs[0]?.id) {
            try {
              console.log(`[DEBUG] Sending to content script in tab ${tabs[0].id}`);
              // ECID DEBUG: Ensure we pass the complete response object
              const completeRequestInfo = {
                method: requestInfo.method,
                type: requestInfo.type,
                statusCode: requestInfo.statusCode,
                response: requestInfo.response // Make sure response is included
              };
              console.log(`[ECID DEBUG] Sending request info to content script:`, completeRequestInfo);
              
              chrome.tabs.sendMessage(tabs[0].id, {
                action: 'displayResults',
                results,
                url: url,
                requestInfo: completeRequestInfo,
                fullXdm: targetObject // Send the full XDM object
              });
            } catch (e) {
              console.error('[DEBUG] Error sending message to content script:', e);
            }
          } else {
            console.log('[DEBUG] No active tab found to send results to');
          }
        });
        
        // Also send to any connected DevTools panels
        try {
          console.log('[DEBUG] Sending to DevTools panel');
          // ECID DEBUG: Ensure we pass the complete response object
          const completeRequestInfo = {
            method: requestInfo.method,
            type: requestInfo.type,
            statusCode: requestInfo.statusCode,
            response: requestInfo.response // Make sure response is included
          };
          console.log(`[ECID DEBUG] Sending request info to DevTools panel:`, completeRequestInfo);
          
          sendToDevTools({
            action: 'displayResults',
            results,
            url: url,
            requestInfo: completeRequestInfo,
            fullXdm: targetObject // Send the full XDM object
          });
        } catch (e) {
          console.log('[DEBUG] Error sending to DevTools:', e.message);
        }
      } else {
        console.log(`[DEBUG] No matches found in data, nothing to display`);
      }
    } else if (jsonData.meta || jsonData.requestId) {
      console.log(`[DEBUG] Processing data without events array`);
      // For requests that don't have events array but might have metadata
      const results = {};
      let hasMatches = false;
      
      // Try to find matches in top-level objects
      console.log(`[DEBUG] Searching for ${targetPaths.length} target paths in top-level objects`);
      targetPaths.forEach(path => {
        const value = getNestedProperty(jsonData, path);
        if (value !== undefined) {
          console.log(`[DEBUG] Found match for path ${path}:`, value);
          results[path] = value;
          hasMatches = true;
        } else {
          console.log(`[DEBUG] No match found for path ${path}`);
        }
      });
      
      if (hasMatches) {
        console.log(`[DEBUG] Has matches in metadata: ${hasMatches}. Results:`, results);
        // Send results to content script and DevTools panel
        try {
          chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs[0]?.id) {
              console.log(`[DEBUG] Sending metadata results to content script in tab ${tabs[0].id}`);
              chrome.tabs.sendMessage(tabs[0].id, {
                action: 'displayResults',
                results,
                url: url,
                requestInfo: {
                  method: requestInfo.method,
                  type: requestInfo.type,
                  statusCode: requestInfo.statusCode
                },
                fullXdm: jsonData // Pass the full object
              });
            } else {
              console.log('[DEBUG] No active tab found for metadata results');
            }
          });
          
          console.log('[DEBUG] Sending metadata results to DevTools panel');
          sendToDevTools({
            action: 'displayResults',
            results,
            url: url,
            requestInfo: {
              method: requestInfo.method,
              type: requestInfo.type,
              statusCode: requestInfo.statusCode
            },
            fullXdm: jsonData // Pass the full object
          });
        } catch (e) {
          console.error('[DEBUG] Error handling data without events array:', e);
        }
      } else {
        console.log(`[DEBUG] No matches found in metadata, nothing to display`);
      }
    } else {
      console.log(`[DEBUG] Data doesn't have events array or metadata, structure:`, Object.keys(jsonData));
    }
  } catch (error) {
    console.error('[DEBUG] Error processing Adobe Web SDK request:', error);
  }
}

// Helper function to get all possible paths in an object (for debugging)
function getAllPaths(obj, currentPath = '', paths = []) {
  if (!obj || typeof obj !== 'object') return paths;

  Object.keys(obj).forEach(key => {
    const newPath = currentPath ? `${currentPath}.${key}` : key;
    paths.push(newPath);
    
    if (obj[key] && typeof obj[key] === 'object') {
      getAllPaths(obj[key], newPath, paths);
    }
  });
  
  return paths;
}

// Listen for request headers being sent (happens for all request types)
chrome.webRequest.onBeforeSendHeaders.addListener(
  (details) => {
    if (!isListening) {
      return { cancel: false };
    }
    
    // Check if this looks like an Adobe Web SDK request
    const isAdobeRequest = isAdobeWebSdkUrl(details.url);
    
    // Determine the request type
    const requestType = getRequestType(details.url, details.type, details.requestHeaders);
    
    // Early return if not an Adobe request
    if (!isAdobeRequest) {
      return { cancel: false };
    }
    
    // Log all detected Adobe requests if in debug mode
    if (debugMode) {
      console.log(`[DEBUG] Detected Adobe Web SDK request: ${details.method} ${requestType} to ${details.url}`);
    }
  },
  { urls: ["<all_urls>"] }
);

// Listen for request data being sent
chrome.webRequest.onSendHeaders.addListener(
  (details) => {
    if (!isListening) {
      return { cancel: false };
    }
    
    // Check if this looks like an Adobe Web SDK request
    const isAdobeRequest = isAdobeWebSdkUrl(details.url);
    
    // Early return if not an Adobe request
    if (!isAdobeRequest) {
      return { cancel: false };
    }
    
    // Store request in cache
    requestCache.set(details.requestId, {
      url: details.url,
      method: details.method,
      type: details.type,
      timestamp: Date.now()
    });
    
    // Log all detected Adobe requests if in debug mode
    if (debugMode) {
      console.log(`[DEBUG] Caching request data for ${details.requestId}: ${details.url}`);
    }
  },
  { urls: ["<all_urls>"] }
);

// Capture request data for processing
chrome.webRequest.onBeforeRequest.addListener(
  (details) => {
    if (!isListening) {
      return { cancel: false };
    }
    
    // Check if this looks like an Adobe Web SDK request
    const isAdobeRequest = isAdobeWebSdkUrl(details.url);
    
    // Early return if not an Adobe request
    if (!isAdobeRequest) {
      return { cancel: false };
    }
    
    // Only process POST requests with request bodies
    if (details.method === 'POST' && details.requestBody) {
      const requestData = details.requestBody.raw ? 
        decodeURIComponent(String.fromCharCode.apply(null, new Uint8Array(details.requestBody.raw[0].bytes))) : 
        '';
      
      if (requestData) {
        // Log request data if in debug mode
        if (debugMode) {
          console.log(`[DEBUG] Processing request body for ${details.url}`);
        }
        
        // Get cached request info
        const requestInfo = requestCache.get(details.requestId) || { 
          url: details.url,
          method: details.method,
          type: details.type
        };
        
        // Process the data
        processRequestData(requestData, details.url, requestInfo);
      }
    }
  },
  { urls: ["<all_urls>"] },
  ["requestBody"]
);

// Capture response data
chrome.webRequest.onHeadersReceived.addListener(
  (details) => {
    if (!isListening) {
      return { cancel: false };
    }
    
    // Check if this looks like an Adobe Web SDK request
    const isAdobeRequest = isAdobeWebSdkUrl(details.url);
    
    // Early return if not an Adobe request
    if (!isAdobeRequest) {
      return { cancel: false };
    }
    
    // Update cached request with status code
    const requestInfo = requestCache.get(details.requestId);
    if (requestInfo) {
      requestInfo.statusCode = details.statusCode;
      requestCache.set(details.requestId, requestInfo);
      
      if (debugMode) {
        console.log(`[DEBUG] Updated request ${details.requestId} with status code ${details.statusCode}`);
      }
    }
  },
  { urls: ["<all_urls>"] },
  ["responseHeaders"]
);

// Clean up request cache periodically
setInterval(() => {
  const now = Date.now();
  const expiredRequests = [];
  
  // Find expired requests (older than 5 minutes)
  requestCache.forEach((requestInfo, requestId) => {
    if (now - requestInfo.timestamp > 5 * 60 * 1000) {
      expiredRequests.push(requestId);
    }
  });
  
  // Remove expired requests
  expiredRequests.forEach(requestId => {
    requestCache.delete(requestId);
  });
  
  if (debugMode && expiredRequests.length > 0) {
    console.log(`[DEBUG] Cleaned up ${expiredRequests.length} expired requests from cache`);
  }
}, 60 * 1000); // Run every minute